% 11/3/05% % surface:              depth values, in centimeters. High values are far.% monitor_distance:     distance in cm% eye_separation:       eye separation in cm (macaque is 3.8cm)% pixel_size:           size of pixels in cm% % dot_parameters.dotsize_x              Horizontal size of each dot (in pixels)% dot_parameters.dotsize_y              Vertical size of each dot (in pixels)% dot_parameters.dot_density            Percent of pixels occupied by dots% dot_parameters.central_dot_pattern	Specify the full dot pattern here if you like. %                                       Overrides 'dot_parameters.dot_density'.% % Output will be same size as original.% surface = make_gaussian(100, 2, 1, 0);% monitor_distance = 57;% eye_separation = 3.8;% pixel_size = 10/330;function [image_left, image_right, disparity_range] = MakeStereogram_Sparse(surface, monitor_distance, eye_separation, pixel_size, dot_parameters)T = eye_separation;w = size(surface,2);h = size(surface,1);% Choose dot sizeif (isfield(dot_parameters, 'dotsize_x') & isfield(dot_parameters, 'dotsize_y'))    dotsize_x = dot_parameters.dotsize_x;    dotsize_y = dot_parameters.dotsize_y;elseif (isfield(dot_parameters, 'dotsize_x'))    dotsize_x = dot_parameters.dotsize_x;    dotsize_y = dot_parameters.dotsize_x;elseif (isfield(dot_parameters, 'dotsize_y'))    dotsize_x = dot_parameters.dotsize_y;    dotsize_y = dot_parameters.dotsize_y;else    dotsize_x = 3;    dotsize_y = 3;enddotsize_r_x = dotsize_x/2;dotsize_r_y = dotsize_y/2;% Choose dot densityif (isfield(dot_parameters, 'dot_density'))    dot_density = dot_parameters.dot_density;else    dot_density = 0.25;end% Add the depth offset.Z = surface + monitor_distance;d = T - T*monitor_distance./Z;      % disparity, in cmd = d/pixel_size;                   % disparity, in number of pixelsdisparity_range = [min(d(:)), max(d(:))];% Generate random dotsif (isfield(dot_parameters, 'central_dot_pattern'))    central_dot_pattern = dot_parameters.central_dot_pattern;	sdot_locations = central_dot_pattern(:,1:2);	sdot_colors = central_dot_pattern(:,3);	n_sdots = size(sdot_locations,1);else	n_sdots = round(dot_density * prod(size(surface)) / (dotsize_x*dotsize_y));	sdot_locations = rand(n_sdots, 2);	sdot_locations(:,1) = sdot_locations(:,1) * size(surface,1);	% y coord	sdot_locations(:,2) = sdot_locations(:,2) * size(surface,2);	% x coord, monocular image	sdot_colors = 2*(rand(n_sdots,1) < 0.5) - 1;endsdot_locations_rounded = round( 0.5 + sdot_locations );			% for determining the disparity% Paint each dotmargin = max(dotsize_x, dotsize_y) + 100;image_left = zeros(size(surface,1) + 2*margin, size(surface,2) + 2*margin);image_right = image_left;for d_i = 1:n_sdots	d_cur = d(sdot_locations_rounded(d_i,1), sdot_locations_rounded(d_i,2));	y = sdot_locations(d_i,1);	xL = sdot_locations(d_i,2) - d_cur/2;	xR = sdot_locations(d_i,2) + d_cur/2;		% Compute the transparency of each affected pixel	 y_range = floor(y  - dotsize_r_y) : ceil(y  + dotsize_r_y);	xL_range = floor(xL - dotsize_r_x) : ceil(xL + dotsize_r_x);	xR_range = floor(xR - dotsize_r_x) : ceil(xR + dotsize_r_x);	 yt = ones(size( y_range));	xLt = ones(size(xL_range));	xRt = ones(size(xR_range));	yt(1)    = 1 - (y  - dotsize_r_y) + floor(y  - dotsize_r_y);	xLt(1)   = 1 - (xL - dotsize_r_x) + floor(xL - dotsize_r_x);	xRt(1)   = 1 - (xR - dotsize_r_x) + floor(xR - dotsize_r_x);	yt(end)  = 1 - ceil(y  + dotsize_r_y) + (y  + dotsize_r_y);	xLt(end) = 1 - ceil(xL + dotsize_r_x) + (xL + dotsize_r_x);	xRt(end) = 1 - ceil(xR + dotsize_r_x) + (xR + dotsize_r_x);		for dy_i = 1:length(y_range)		dy = y_range(dy_i);		for dx_i = 1:length(xR_range)			tR = yt(dy_i) * xRt(dx_i);				% transparency percentage for each pixel on the sdot			image_right(dy+margin, xR_range(dx_i)+margin) = (1-tR)*image_right(dy+margin, xR_range(dx_i)+margin) + tR*sdot_colors(d_i);		end		for dx_i = 1:length(xL_range)			tL = yt(dy_i) * xLt(dx_i);			image_left(dy+margin, xL_range(dx_i)+margin)  = (1-tL)*image_left(dy+margin, xL_range(dx_i)+margin) + tL*sdot_colors(d_i);		end    endendimage_left  =  image_left(margin + (1:h), margin + (1:w));image_right = image_right(margin + (1:h), margin + (1:w));